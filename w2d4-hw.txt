What's New in Android:
Picture in Picture support. Color management with support for 16 bit, ICC profiles in JPEG/PNG/WebP. Multi-window = multi-display (user controlled) or app controlled with. Activity options; use adb shell. Playback getMetrics() query information, codec, duratoin, bitrate, etc. Improved buffering control, watermarks to specify amount to preload, buffering can be specified in size or time or both; Seeking, and DRM playback. Recording has new support for the MPEG-2 TS stream format; arbitary number of tracks. WebView has safe browsing, multi-process: security and robustness, termination handle and renderer importance APIs handle crashes and low memory situations. Animator features using AnimatorSet, you can seek for child animators within an animator set and can also reverse. Autofill update because filling in forms is tedious. You can put fonts directly into a resource called font directory; can provide font families. You can download and cache a font. You can auto-size text views, resizes the font for you. These can be found on the service library.AcceessibilityService Utiliies with language detection, accessibility button, seperate volume controls and fingerprint gestures. findViewById no longer needs casting! Adapative icons, here's my background, here's my foreground, cut it out to whatever you like. Notifications introducing notification channels, category of notifications, long-press a notification to see it's channel and adjust the channel behavior. Users wanted to change some of the notifications instead of all. Strict Mode so you can get warned when you have unbuffered I/O under ThreadPolicy and untagged sockets, permissions under VmPolicy. Seekable file descriptors from custom document providers for Media File Access; for large types of content. Stay below the quota to avoid aggressive deletion (Cached Data); it'll truncate the file to show the cache has been deleted. 
Google Play Protect enabled on all devices with Google Play all apps on Play are pre-screened every app screened on install (even if it didn't come from Play). Official support for Kotlin was announced! Java has new packages for time, file and invoke. Runtime has a new concurrent-copying collector, making it faster doing everything in the background. Heap compaction in the foreground (smaller heap, faster allocations, faster collections). Optimizations (loop unrolling, inlining, escape analysis...) DEX locality makes for easier and faster to access as applications load up. Support Library v26 has O Features ported and Emoji Compat. Physics animation system to show accurate velocities when dragging something. Working to make sure background (location) services are not being used if not needed to save battery power.

Speeding Up Your Android Gradle Builds:
1. Make sure to use the latest Androd Gradle plugin
2. Avoid legacy multi-dex, if you use below version 21 multidex, it'll slow down the build significantly
3. Should disable multi-APK generation, using the split block creates multiple smaller APKs that target specific device configurations for release. Not important for development builds. Define a property that is passed to gradle to disable. 
4. Minimize set of resources that you package in your development build. It packages all languages and screen densities needed for your app but that's useless when doing the actual development.
5. Disable PNG crunching, it does PNG optimization by default which is again not useful during development. Set the cruncher to false as a property. Or convert PNGs to webps. 
6. Use Instant Run, only works on API level 21 or above. Now a Run and Apply Changes button used. 
7. Avoid inadvertent changes; ex: having a timestamp for every build is unnecessary if you are not sharing the build with others. 
8. Should not use dynamic versions; don't use the + sign in the dependecies 
9. Be careful about amount of memory given to Gradle
10. Enable the new Gradle cache: can cache all the task outputs, enables distributed caching. 
Full Build is 3x faster, Java incremental build is 12x faster and resource incremental build is 3x faster.
Multi-module projects: app depends on lib1 depends on lib2; before lib2 compilation would trigger compilation in lib1 and in app. In 3.0, uses ABI, if it's an ABI change we'd use the before scenario, otherwise we wouldn't recompile at all. If you have 250 modules, it'll recompile them all! 
Compile is now deprecated and replace with api or implementation.
Api is the equivalent of old compile, imported modules public APIs become your API, it's easy but dangerous.
Implementation, imported modules not re-exported and consumers of your module do not see the public APIs of "implementation" imported modules
Now it only recompiles the modules it's supports, saving a lot of time.
Gradle can build modules in parallel, workaround for lack of incremental tasks, multiple modules -> multiple tasks -> parallel execution and some parallelism within a tassk is provided but limited.
Slow build are NOT normal
What can go wrong: third party plugins, incorrect code organization, Build.gradle customization gone wild, incorrect settings (memory)
doLast is dangerous because Gradle is lost, write a plugin and custom task with inputs instead so it's cacheable.
--profile is a simple tool that will output a .html page with each task's execution timing.
Gradle profiler can do benchmarking and profiling of the build, file performance bugs.

Notifications UX: What's New for Android O:
Did user research on how they use notifications. This included in-depth interviews, observations, group discussions and data synthesis. Addiction to phones, for fear of missing an important notification. Notifications were a source of stress; only a few of them were neccessary. They'd physically put the phone away, don't let the device make noise, don't let sources contact you or constantly be annoyed as ways to avoid it. People don't adjust their settings because they don't know how or it's a hassle. The most important were from people on the other end; notifications from the inner circle are even more important. The second important notification were reminders. 
Feature Channels: define a channel for each type of notification it plans to send, and the user has channel-level notification controls so they're not forced to make all-or-nothing decisions; categorize notifications into channels
Can block all notifications from app, hide a notification dot from app, see all channels at a glance and quickly turn off unwanted ones, view and edit settings for a channel, and navigate back to the app's settings if link provided.
Current model uses a priority level which maps to a set of behaviors, some of which are customizable by the app but in the new model priority is deprecated, importance level for channels instead.
Current model a user can prevent any app from applying certain behaviors but UI doesn't expose priority model but in the new model most behavior is baked into importance model, which user can see and change for each channel. 
Android has a page for every channel from every app; description, block channel, importance level, etc.
Bucket notification types into a dedicated secton within the drawer: Major Ongoing, People to People, General, By The Way. Most critical notifications appear first. Ranking notifications in each section.
Major Ongoing: Time sensitive content users should be actively aware of, must be running in a foreground service or using MediaStyle with MediaSession
People to People: Content from a person, should use MessagingStyle and direct reply or attach a contact. Can read more without expanding.
General: Well-timed and informative task reminders, no changes in O
BTW: Contextual or informative but non-urgent content (weather traffic, suggestions, promotions), Set as IMPORTANCE_MIN
Snoozing: Partial swipe with a snooze button to snooze a notification during a set duration. 
 
What's New in Android Development Tools:
Went from 2.3 to 3.0. Parameter hints and emoticons. You can enable Kotlin from the get-go. Convert Java file to Kotlin. Invoke show byte window, to see the bytes of a section. Decompose changes it back to Java. Layout Editor: Better handling of errors and constraint layout. Chains to distibute widgets among an axis, can be aligned and a chain cycle button. Supports sample data. Sample resource type option. JSON class can be used by binding to the view.xml, when you go to the layout you see something much similar to what you expect from the app. More fonts option in the layout to see all fonts available online and it'll show the new font. You can edit the forefront and background layers for an icon. A device explorer in the button right, and you can right click files to upload them to the application. Can extract all the classes at the same time (that work together). APK analyzer has more support for DEX and. APK debugging allows you to point to a random APK and make a shell project. Profiler attaches to the process and shows the CPU, memory and network. Supports OK HTTP 1 since Canary. Click "recording" to watch stuff from the app in the profiler. You can narrow the focus on a particular range you want to see. You can check the heap dump, and can chase down the references to look for a leak. Use Maven repository to get new features/updates. Java Compilation, Dexing and APK Packaging is now incremental. Build caching local (switching between branches without recompiling) and distributed (Share with team memberrs And Build Server; Hazelcast implementation, Gradle Enterprise). 
Multi-module advantages: Code Reuse, Improved Caching, APi / Dependency Control and Compilation Avoidance. Went from 3 minutes to 2 seconds to build a large project with Gradle. Parallel Build Bottlenecks can publish the AARs seperately instead of all at once. Removed the need for jack to use Java 8. 
Change libraries to features, publishes an AAR and a feature APK. 
Added Google Play Store, OpenGL ES 3.0 and Proxy Support to the emulator.
App Bug Reporting system by clicking a button to share with other developers.
Added Emulator Rotary Support and Layout Inspector. 
WebP support added. 

The experts' guide to Android developement tools:
Command Line tools to use diff and merge with projects. VM options will make a new VM resource file and you can check the project location of the file. Control-Shift-J for a smart join, removes the + operations for a string. Open Intent Menu on String, copy concatenation value to clipboard. Pressing tab instead of enter when trying to change a method using the tools removes the old method call instead of adding to it. You can use a shortcut to call the instantiation for you. Multiple cursors for the same name. Control-Shift-A brings up the action menu. Bookmark with Control-Shift-Number. Expression selection tool, extracts it to a method. You can take an array and type "for", "fori" or "forr" to automate a for loop for the array. With complex operations you can use the Intent menu to change the style of the operations. Control Shift Space gives the correct operations for the specific context. Command-Shift-A: Local History to check a diff between the current iteration vs some of the older saves. 
Open Intent menu, Attach debugger to Android process, select the process and click OK. Examine programs in a messed up state. Mute breakpoints. Can re-enable it when you're program is in a state where you want to debug again. Set a condition or evaluate an expression at a breakpoint instead. Disabled until selected breakpoint is hit is an option. (22:33/45:07)

In-App Billing Version 3:
